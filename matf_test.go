package matf

import (
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"regexp"
	"testing"
)

var (
	noMatf     = []byte{0x6e, 0x6f, 0x4d, 0x61, 0x74, 0x66}
	matfHeader = []byte{0x41, 0x4d, 0x4c, 0x54, 0x42, 0x41, 0x35, 0x20, 0x30, 0x2e, 0x4d, 0x20, 0x54, 0x41, 0x66, 0x2d,
		0x6c, 0x69, 0x2c, 0x65, 0x77, 0x20, 0x69, 0x72, 0x74, 0x74, 0x6e, 0x65, 0x62, 0x20, 0x20, 0x79,
		0x63, 0x4f, 0x61, 0x74, 0x65, 0x76, 0x34, 0x20, 0x32, 0x2e, 0x32, 0x2e, 0x20, 0x2c, 0x30, 0x32,
		0x38, 0x31, 0x30, 0x2d, 0x2d, 0x34, 0x31, 0x30, 0x31, 0x20, 0x3a, 0x32, 0x34, 0x35, 0x32, 0x3a,
		0x20, 0x36, 0x54, 0x55, 0x20, 0x43, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x00, 0x4d, 0x49}
	matfHeaderMI = []byte{0x41, 0x4d, 0x4c, 0x54, 0x42, 0x41, 0x35, 0x20, 0x30, 0x2e, 0x4d, 0x20, 0x54, 0x41, 0x66, 0x2d,
		0x6c, 0x69, 0x2c, 0x65, 0x77, 0x20, 0x69, 0x72, 0x74, 0x74, 0x6e, 0x65, 0x62, 0x20, 0x20, 0x79,
		0x63, 0x4f, 0x61, 0x74, 0x65, 0x76, 0x34, 0x20, 0x32, 0x2e, 0x32, 0x2e, 0x20, 0x2c, 0x30, 0x32,
		0x38, 0x31, 0x30, 0x2d, 0x2d, 0x34, 0x31, 0x30, 0x31, 0x20, 0x3a, 0x32, 0x34, 0x35, 0x32, 0x3a,
		0x20, 0x36, 0x54, 0x55, 0x20, 0x43, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x00, 0x49, 0x4d}
	oneXoneMatrix = []byte{0x00, 0x0e, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
		0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
		0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x63, 0x00, 0x00,
		0x00, 0x01, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00}
	completeMatf = []byte{0x4d, 0x41, 0x54, 0x4c, 0x41, 0x42, 0x20, 0x35, 0x2e, 0x30, 0x20, 0x4d, 0x41, 0x54, 0x2d, 0x66,
		0x69, 0x6c, 0x65, 0x2c, 0x20, 0x77, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e, 0x20, 0x62, 0x79, 0x20,
		0x4f, 0x63, 0x74, 0x61, 0x76, 0x65, 0x20, 0x34, 0x2e, 0x32, 0x2e, 0x32, 0x2c, 0x20, 0x32, 0x30,
		0x31, 0x38, 0x2d, 0x30, 0x35, 0x2d, 0x32, 0x35, 0x20, 0x30, 0x39, 0x3a, 0x31, 0x36, 0x3a, 0x33,
		0x38, 0x20, 0x55, 0x54, 0x43, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x01, 0x49, 0x4d,
		0x0e, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x66, 0x69, 0x72, 0x73, 0x74, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f, 0x0e, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
		0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x00, 0x00,
		0x09, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40}
)

func TestCheckIndex(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		in   int
		out  int
	}{
		{name: "1", in: 1, out: 8},
		{name: "7", in: 7, out: 8},
		{name: "8", in: 8, out: 8},
		{name: "9", in: 9, out: 16},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			ret := checkIndex(tc.in)
			if ret != tc.out {
				t.Fatalf("Expected: %v \t Got: %v", tc.out, ret)
			}
		})
	}
}

func TestOpen(t *testing.T) {
	t.Parallel()

	tdir, ferr := ioutil.TempDir("", "TestOpen")
	if ferr != nil {
		t.Fatal(ferr)
	}
	defer os.RemoveAll(tdir)

	notValid, ferr := ioutil.TempFile(tdir, "noMatf.mat")
	if ferr != nil {
		t.Fatal(ferr)
	}
	defer os.Remove(notValid.Name())

	ferr = ioutil.WriteFile(notValid.Name(), noMatf, 0644)
	if ferr != nil {
		t.Fatal(ferr)
	}
	defer notValid.Close()

	headerOnly, ferr := ioutil.TempFile(tdir, "headerOnly.mat")
	if ferr != nil {
		t.Fatal(ferr)
	}
	defer os.Remove(headerOnly.Name())

	ferr = ioutil.WriteFile(headerOnly.Name(), matfHeader, 0644)
	if ferr != nil {
		t.Fatal(ferr)
	}
	defer headerOnly.Close()

	headerOnlyMI, ferr := ioutil.TempFile(tdir, "headerOnlyMI.mat")
	if ferr != nil {
		t.Fatal(ferr)
	}
	defer os.Remove(headerOnlyMI.Name())

	ferr = ioutil.WriteFile(headerOnlyMI.Name(), matfHeaderMI, 0644)
	if ferr != nil {
		t.Fatal(ferr)
	}
	defer headerOnlyMI.Close()

	tests := []struct {
		name string
		in   string
		err  string
		mat  *Matf
	}{
		{name: "Empty Input", in: "", err: "no such file or directory"},
		{name: "No Matf", in: notValid.Name(), err: "Could not read enough bytes"},
		{name: "Header Only", in: headerOnly.Name()},
		{name: "Header Only MI", in: headerOnlyMI.Name()},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			_, err := Open(tc.in)
			if err != nil {
				if matched, _ := regexp.MatchString(tc.err, err.Error()); matched == false {
					t.Fatalf("Error matching regex: %v \t Got: %v", tc.err, err)
				}
			} else if len(tc.err) != 0 {
				t.Fatalf("Expected error, got none")
			}
		})
	}
}

func TestDecompressData(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name   string
		input  []byte
		output []byte
		err    string
	}{
		{name: "DeadCell", input: []byte{0x78, 0x9c, 0xba, 0xb7, 0xf6, 0x9c, 0x20, 0x20, 0x00, 0x00, 0xff, 0xff, 0x07, 0x30, 0x02, 0x6b}, output: []byte{0xDE, 0xAD, 0xCE, 0x11}},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			output, err := decompressData(tc.input)
			if err != nil {
				if matched, _ := regexp.MatchString(tc.err, err.Error()); matched == false {
					t.Fatalf("Error matching regex: %v \t Got: %v", tc.err, err)
				}
				return
			} else if len(tc.err) != 0 {
				t.Fatalf("Expected error, got none")
			}
			fmt.Printf("Expected: %#v\tGot: %#v\n", tc.output, output)
		})
	}
}

func TestDimensions(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		mat  MatMatrix
		x    int
		y    int
		z    int
		err  string
	}{
		{name: "1 Dim", mat: MatMatrix{Dim: Dim{X: 2, Y: 0, Z: 0}}, x: 2},
		{name: "2 Dim", mat: MatMatrix{Dim: Dim{X: 3, Y: 5, Z: 0}}, x: 3, y: 5},
		{name: "3 Dim", mat: MatMatrix{Dim: Dim{X: 7, Y: 11, Z: 13}}, x: 7, y: 11, z: 13},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			x, y, z, err := tc.mat.Dimensions()
			if err != nil {
				if matched, _ := regexp.MatchString(tc.err, err.Error()); matched == false {
					t.Fatalf("Error matching regex: %v \t Got: %v", tc.err, err)
				}
				return
			} else if len(tc.err) != 0 {
				t.Fatalf("Expected error, got none")
			}
			if tc.x != x {
				t.Fatalf("Expected x: %d\tgot: %d", tc.x, x)
			} else if tc.y != y {
				t.Fatalf("Expected y: %d\tgot: %d", tc.y, y)
			} else if tc.z != z {
				t.Fatalf("Expected z: %d\tgot: %d", tc.x, z)
			}
		})
	}
}

func TestMatf(t *testing.T) {
	tdir, ferr := ioutil.TempDir("", "TestMatf")
	if ferr != nil {
		t.Fatal(ferr)
	}
	defer os.RemoveAll(tdir)

	simple, ferr := ioutil.TempFile(tdir, "simple.mat")
	if ferr != nil {
		t.Fatal(ferr)
	}
	defer os.Remove(simple.Name())

	ferr = ioutil.WriteFile(simple.Name(), completeMatf, 0644)
	if ferr != nil {
		t.Fatal(ferr)
	}
	defer simple.Close()

	x, err := Open(simple.Name())
	if err != nil {
		t.Fatalf("Could not open test file: %v", err)
	}
	defer Close(x)

	for {
		mat, err := ReadDataElement(x)
		if err == io.EOF {
			break
		} else if err != nil {
			t.Fatalf("Could not open test file: %v", err)
		}
		_ = mat
	}
}
